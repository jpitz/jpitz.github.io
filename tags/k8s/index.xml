<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>k8s on Mya Pitzeruse</title>
    <link>https://mjpitz.com/tags/k8s/</link>
    <description>Recent content in k8s on Mya Pitzeruse</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 03 Dec 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://mjpitz.com/tags/k8s/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Renovate your GitOps</title>
      <link>https://mjpitz.com/blog/2020/12/03/renovate-your-gitops/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mjpitz.com/blog/2020/12/03/renovate-your-gitops/</guid>
      <description>&lt;p&gt;Every engineering organization struggles to stay up to date with the latest versions of applications they run.
When an organization deploys an open source project, their versions start to drift from day one.
The longer a project runs without an update, the more likely it is to contain a vulnerability.
To help applications stay on top of library versions, the project &lt;a href=&#34;https://github.com/renovatebot/&#34;&gt;Renovate&lt;/a&gt; was developed.
Renovate works by parsing manifest files (like &lt;code&gt;package.json&lt;/code&gt; and &lt;code&gt;go.mod&lt;/code&gt;) and checking for newer versions of libraries.
When Renovate discovers an update, it submits a pull request with the newer version to the project.&lt;/p&gt;
&lt;p&gt;Recently, I noticed Renovate submit pull requests for dependencies in my &lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt; v3 charts.
This gave me an idea.
What if Renovate could automatically manage something like a GitOps repository?
This means organizations would no longer need to tediously query for newer versions of applications.
Instead, they&amp;rsquo;d automatically receive a pull request when an update becomes available.
In this blog post, I demonstrate how to set this up for an &lt;a href=&#34;https://github.com/argoproj/argo-cd/&#34;&gt;ArgoCD&lt;/a&gt; GitOps repository.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Adventures in Path Based Routing</title>
      <link>https://mjpitz.com/blog/2020/11/10/path-based-routing-k8s/</link>
      <pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mjpitz.com/blog/2020/11/10/path-based-routing-k8s/</guid>
      <description>&lt;p&gt;Path based routing can be an extremely useful feature.
It enables you to serve a single page app and an API on the same domain.
This can often be helpful when starting a project, but don&amp;rsquo;t want to handle things like &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;cross-origin resource sharing&lt;/a&gt;.
In a recent project, I wanted to split traffic between a static site hosted on GitHub (or S3) and an API running in the cluster.
In this post, I&amp;rsquo;ll demonstrate some less common approaches to path based routing using &lt;a href=&#34;https://kubernetes.io&#34;&gt;Kubernetes&lt;/a&gt; resources.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Local Ingress Domains for your Kind Cluster</title>
      <link>https://mjpitz.com/blog/2020/10/21/local-ingress-domains-kind/</link>
      <pubDate>Wed, 21 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mjpitz.com/blog/2020/10/21/local-ingress-domains-kind/</guid>
      <description>&lt;p&gt;Tools like &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/&#34;&gt;minikube&lt;/a&gt; and &lt;a href=&#34;https://kind.sigs.k8s.io/&#34;&gt;kind&lt;/a&gt; make it easy to get a &lt;a href=&#34;https://kubernetes.io/&#34;&gt;kubernetes&lt;/a&gt; cluster up and running locally.
Unfortunately these tools are limited in their capabilities, namely a lack of load balancer support.
As a result, the community developed solutions like &lt;a href=&#34;https://github.com/txn2/kubefwd&#34;&gt;kubefwd&lt;/a&gt; and &lt;code&gt;minikube tunnel&lt;/code&gt; to expose services.
While this approach works, keeping a dedicated terminal open during development can be tedeous.
In this post, I show how to set up an ingress controller in a kind cluster and pair it with a private, locally addressable domain.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>